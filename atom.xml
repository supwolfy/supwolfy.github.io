<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江枫</title>
  
  <subtitle>芜湖</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-20T09:16:04.180Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>江枫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>集合</title>
    <link href="http://yoursite.com/2020/%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2020/%E9%9B%86%E5%90%88/</id>
    <published>2020-08-19T08:37:27.000Z</published>
    <updated>2020-08-20T09:16:04.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h1><ul><li>为了方便对多个对象的操作，就要对对象进行存储。使用Array（数组）存储对象方面具有一些弊端，如：长度问题，而Java 集合就像一种容器，可以动态地把多个对象的引用放入容器中。</li><li>Java 集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组。</li><li>JDK提供的集合API位于java.util包内</li></ul><h1 id="集合分类"><a href="#集合分类" class="headerlink" title="集合分类"></a>集合分类</h1><ul><li>Java 集合可分为 Collection 和 Map 两种体系<h3 id="1-Collection接口"><a href="#1-Collection接口" class="headerlink" title="1. Collection接口"></a>1. Collection接口</h3><ul><li>Set：元素无序、不可重复的集合</li><li>List：元素有序，可重复的集合<h3 id="2-Map接口"><a href="#2-Map接口" class="headerlink" title="2. Map接口"></a>2. Map接口</h3></li><li>具有映射关系的”key-value”对的集合</li></ul></li></ul><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><img src="/2020/%E9%9B%86%E5%90%88/Collection.png" class="" title="Collection"><ul><li>Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。</li><li>JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。</li><li>在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理；从 Java5 增加了泛型以后，Java 集合可以记住容器中对象的数据类型<h3 id="Collection接口方法"><a href="#Collection接口方法" class="headerlink" title="Collection接口方法"></a>Collection接口方法</h3><h4 id="1-集合操作"><a href="#1-集合操作" class="headerlink" title="1. 集合操作"></a>1. 集合操作</h4></li></ul><table><thead><tr><th>返回类型</th><th>方法</th></tr></thead><tbody><tr><td>boolean</td><td><strong>add(E e)</strong>  确保此collection包含的指定的元素</td></tr><tr><td>boolean</td><td><strong>addAll (Collection&lt;? exrends E&gt; c)</strong>   将指定 collection 中的所有元素都添加到此 collection 中（可选操作）</td></tr><tr><td>void</td><td><strong>clead()</strong> 移除此 collection 中的所有元素（可选操作）</td></tr><tr><td>boolean</td><td><strong>contains(Obejct o)</strong> 如果此 collection 包含指定的元素，则返回 true</td></tr><tr><td>boolean</td><td><strong>containsAll(Collection&lt;?&gt; c)</strong> 如果此 collection 包含指定的 collection 中的所有元素，则返回true</td></tr><tr><td>boolean</td><td><strong>equals(Object o)</strong> 比较此collection 与指定对象是否相等</td></tr><tr><td>int</td><td><strong>hashCode()</strong> 返回此 collection 的哈希值</td></tr><tr><td>boolean</td><td><strong>isEmpty()</strong> 如果此 collection 不包含元素，则返回 true</td></tr></tbody></table><h4 id="2-迭代器操作"><a href="#2-迭代器操作" class="headerlink" title="2.迭代器操作"></a>2.迭代器操作</h4><table><thead><tr><th>返回类型</th><th>方法</th></tr></thead><tbody><tr><td>Iterator</td><td><strong>iterator()</strong> 返回在此 collection 的元素上进行迭代的迭代器</td></tr><tr><td>boolean</td><td><strong>remove(Object o)</strong> 在此 collection 中移除指定元素的单个实例，如果存在的话（可选操作）</td></tr><tr><td>boolean</td><td><strong>removeAll(Collection&lt;?&gt; o)</strong> 移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）</td></tr><tr><td>boolean</td><td><strong>retainAll(Collection&lt;?&gt; o)</strong> 仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）</td></tr><tr><td>int</td><td><strong>size()</strong> 返回此 collection 中的元素数</td></tr><tr><td>Object[]</td><td><strong>toArray()</strong> 返回包含此 collection 中所有元素（集合与数组间转换操作）</td></tr><tr><td><T> T[]</td><td><strong>toArray(T[] a)</strong> 返回包含此 collection 中所有元素的数组，返回数组的运行时类型与指定数组的运行时类型相同（集合与数组间转换操作）</td></tr></tbody></table><h3 id="使用-Iterator-接口遍历集合元素"><a href="#使用-Iterator-接口遍历集合元素" class="headerlink" title="使用 Iterator 接口遍历集合元素"></a>使用 Iterator 接口遍历集合元素</h3><ul><li>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。</li><li>所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。</li><li><strong>Iterator 仅用于遍历集合</strong>，Iterator 本身并不提供承装对象的能力。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。</li></ul><h3 id="Iterator接口的方法"><a href="#Iterator接口的方法" class="headerlink" title="Iterator接口的方法"></a>Iterator接口的方法</h3><img src="/2020/%E9%9B%86%E5%90%88/image-20200820171522891.png" class="" title="image-20200820171522891"><ul><li>在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。</li></ul><h3 id="使用-foreach-循环遍历集合元素"><a href="#使用-foreach-循环遍历集合元素" class="headerlink" title="使用 foreach 循环遍历集合元素"></a>使用 foreach 循环遍历集合元素</h3><img src="/2020/%E9%9B%86%E5%90%88/foreach.png" class="" title="foreach"><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForandEach</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">             String[] str = <span class="keyword">new</span> String[<span class="number">5</span>];  <span class="comment">//null</span></span><br><span class="line">             <span class="keyword">for</span>(String myStr : str)&#123;</span><br><span class="line">                    myStr = “hello<span class="string">&quot;;</span></span><br><span class="line"><span class="string">                    System.out.println(myStr);  //5个hello</span></span><br><span class="line"><span class="string">              &#125;</span></span><br><span class="line"><span class="string">             for(int i = 0;i &lt; str.length;i++)&#123;</span></span><br><span class="line"><span class="string">                    System.out.println(str[i]);  //5个null</span></span><br><span class="line"><span class="string">             &#125;</span></span><br><span class="line"><span class="string">       &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><ul><li>Java中数组用来存储数据的局限性</li><li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</li><li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li><li>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector(线程安全)。</li></ul><h3 id="List接口方法"><a href="#List接口方法" class="headerlink" title="List接口方法"></a>List接口方法</h3><pre><code>- void add(int index, Object ele)- boolean addAll(int index, Collection eles)- Object get(int index)- int indexOf(Object obj)- int lastIndexOf(Object obj)- Object remove(int index)- Object set(int index, Object ele)- List subList(int fromIndex, int toIndex)</code></pre><h3 id="List实现类之一：ArrayList"><a href="#List实现类之一：ArrayList" class="headerlink" title="List实现类之一：ArrayList"></a>List实现类之一：ArrayList</h3><ul><li>ArrayList 是 List 接口的典型实现类</li><li>本质上，ArrayList是对象引用的一个变长数组</li><li>ArrayList 是线程不安全的，而 Vector 是线程安全的，即使为保证 List 集合线程安全，也不推荐使用Vector</li><li>Arrays.asList(…) 方法返回值是一个固定长度的 List 集合</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;nanjing&quot;</span>);        <span class="comment">//在末尾添加</span></span><br><span class="line">        list1.add(<span class="number">0</span>, <span class="string">&quot;shanghai&quot;</span>);     <span class="comment">//在指定位置添加</span></span><br><span class="line">        list1.add(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;List size:&quot;</span>+list1.size());    <span class="comment">//获取元素个数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //1.利用get获取指定位置的元素</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;list1.size();i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(list1.get(i));</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        //2.用迭代器(由前向后移动，不能添加元素)</span></span><br><span class="line"><span class="comment">        Iterator&lt;String&gt; it = list1.iterator();        //获取迭代器对象</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        while(it.hasNext())</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            String element = it.next();        //获取当前元素</span></span><br><span class="line"><span class="comment">            System.out.println(element);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        //数据的删除&amp;修改&amp;查找</span></span><br><span class="line"><span class="comment">        list1.remove(1);            //删除某位置元素</span></span><br><span class="line"><span class="comment">        list1.remove(&quot;nanjing&quot;);    //删除指定元素</span></span><br><span class="line"><span class="comment">        list1.set(0, &quot;tianjin&quot;);    //修改某位置元素</span></span><br><span class="line"><span class="comment">        list1.contains(&quot;xian&quot;);        //查修某位置元素</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//利用迭代器实现数据的删除&amp;修改&amp;增加(可以双向移动,使用list)</span></span><br><span class="line">        ListIterator&lt;String&gt; lit = list1.listIterator();    <span class="comment">//仅对list有效</span></span><br><span class="line">        lit.next();</span><br><span class="line">        lit.remove();         <span class="comment">//删除(前一个元素)</span></span><br><span class="line">        lit.add(<span class="string">&quot;wuhan&quot;</span>);     <span class="comment">//添加完后游标在新元素后面</span></span><br><span class="line">        System.out.println(lit.previousIndex()+<span class="string">&quot;&lt;=====&gt;&quot;</span>+lit.nextIndex());</span><br><span class="line">        lit.add(<span class="string">&quot;hangzhou&quot;</span>);</span><br><span class="line">        System.out.println(lit.previousIndex()+<span class="string">&quot;&lt;=====&gt;&quot;</span>+lit.nextIndex());</span><br><span class="line">        lit.next();</span><br><span class="line">        lit.set(<span class="string">&quot;lanzhou&quot;</span>);     <span class="comment">//修改(前一个元素)  不可在add()后用set()</span></span><br><span class="line">        System.out.println(lit.previousIndex()+<span class="string">&quot;&lt;=====&gt;&quot;</span>+lit.nextIndex());</span><br><span class="line">        <span class="keyword">while</span>(lit.hasNext())    <span class="comment">//判断后一个元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(lit.hasPrevious())    <span class="comment">//判断前一个元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.previous());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(lit.hasNext())    <span class="comment">//判断后一个元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.next());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String s:list1)        <span class="comment">//增强的for循环,遍历集合</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(list1);    <span class="comment">//集合重写了toString(),可以直接输出</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//排序的方式</span></span><br><span class="line">        MyComparator comparator = <span class="keyword">new</span> MyComparator();</span><br><span class="line">        list1.sort(comparator);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;\nafter sort....\n&quot;</span>+list1);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自定义规则</span></span><br><span class="line">        <span class="comment">//return o1.length()-o2.length();    //根据字符长度排序</span></span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);        <span class="comment">//根据字符排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List size:3</span><br><span class="line">0&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;1</span><br><span class="line">1&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;2</span><br><span class="line">2&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;3</span><br><span class="line">beijing</span><br><span class="line">-------------</span><br><span class="line">beijing</span><br><span class="line">lanzhou</span><br><span class="line">hangzhou</span><br><span class="line">wuhan</span><br><span class="line">-------------</span><br><span class="line">wuhan</span><br><span class="line">hangzhou</span><br><span class="line">lanzhou</span><br><span class="line">beijing</span><br><span class="line">-------------</span><br><span class="line">wuhan</span><br><span class="line">hangzhou</span><br><span class="line">lanzhou</span><br><span class="line">beijing</span><br><span class="line">[wuhan, hangzhou, lanzhou, beijing]</span><br><span class="line"></span><br><span class="line">after sort....</span><br><span class="line">[beijing, hangzhou, lanzhou, wuhan]</span><br></pre></td></tr></table></figure><h3 id="List实现类之二：LinkedList"><a href="#List实现类之二：LinkedList" class="headerlink" title="List实现类之二：LinkedList"></a>List实现类之二：LinkedList</h3><ul><li>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高</li><li>新增方法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- void addFirst(Object obj)</span><br><span class="line">- void addLast(Object obj)    </span><br><span class="line">- Object getFirst()</span><br><span class="line">- Object getLast()</span><br><span class="line">- Object removeFirst()</span><br><span class="line">- Object removeLast()</span><br></pre></td></tr></table></figure>示例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//内部实现的是双向链表</span></span><br><span class="line">        LinkedList&lt;String&gt; list1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        list1.add(<span class="string">&quot;nanjing&quot;</span>);    <span class="comment">//在尾部插</span></span><br><span class="line">        list1.add(<span class="string">&quot;beijing&quot;</span>);</span><br><span class="line">        list1.add(<span class="number">0</span>,<span class="string">&quot;shanghai&quot;</span>);    </span><br><span class="line">        System.out.println(list1);</span><br><span class="line"></span><br><span class="line">        list1.addFirst(<span class="string">&quot;hefei&quot;</span>);     <span class="comment">//头插</span></span><br><span class="line">        list1.addLast(<span class="string">&quot;hangzhou&quot;</span>);     <span class="comment">//尾插</span></span><br><span class="line">        System.out.println(list1);</span><br><span class="line"></span><br><span class="line">        list1.removeFirst();    <span class="comment">//去头</span></span><br><span class="line">        System.out.println(list1);</span><br><span class="line"></span><br><span class="line">        list1.removeLast();        <span class="comment">//去尾</span></span><br><span class="line">        System.out.println(list1);</span><br><span class="line"></span><br><span class="line">        list1.listIterator();</span><br><span class="line">        list1.iterator();</span><br><span class="line">        <span class="comment">//古老的技术模型,保证线程安全,效率低,目前很少使用</span></span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();    <span class="comment">//栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>结果：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[shanghai, nanjing, beijing]</span><br><span class="line">[hefei, shanghai, nanjing, beijing, hangzhou]</span><br><span class="line">[shanghai, nanjing, beijing, hangzhou]</span><br><span class="line">[shanghai, nanjing, beijing]</span><br></pre></td></tr></table></figure><h3 id="LinkedList实现类之三：Vertor"><a href="#LinkedList实现类之三：Vertor" class="headerlink" title="LinkedList实现类之三：Vertor"></a>LinkedList实现类之三：Vertor</h3></li><li>Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。</li><li>在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。</li><li>新增方法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- void addElement(Object obj)</span><br><span class="line">- void insertElementAt(Object obj,int index)</span><br><span class="line">- void setElementAt(Object obj,int index)</span><br><span class="line">- void removeElement(Object obj)</span><br><span class="line">- void removeAllElements()</span><br></pre></td></tr></table></figure><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2></li><li>Set接口是Collection的子接口，set接口没有提供额外的方法</li><li>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。</li><li>Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals 方法</li></ul><h3 id="Set实现类之一：HashSet"><a href="#Set实现类之一：HashSet" class="headerlink" title="Set实现类之一：HashSet"></a>Set实现类之一：HashSet</h3><ul><li>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。</li><li>HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。</li><li>HashSet 具有以下特点：<ul><li>不能保证元素的排列顺序</li><li>HashSet 不是线程安全的</li><li>集合元素可以是 null</li></ul></li><li>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值决定该对象在 HashSet 中的存储位置。</li><li>HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。       </li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//User类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User [id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age +  <span class="string">&quot;, hashCode=&quot;</span></span><br><span class="line">                + hashCode() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        result = prime * result + age;</span><br><span class="line">        result = prime * result + id;</span><br><span class="line">        result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        User other = (User) obj;</span><br><span class="line">        <span class="keyword">if</span> (age != other.age)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (id != other.id)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.name != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id - o.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类：</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="comment">//String类实现了hashCode和equals方法,给set提供了判断依据</span></span><br><span class="line">        set.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;Tomos&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        set.add(<span class="string">&quot;Tom&quot;</span>);    <span class="comment">//不重复性</span></span><br><span class="line">        System.out.println(set);</span><br><span class="line">        </span><br><span class="line">        HashSet&lt;User&gt; users = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">&quot;Jerry&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        users.add(u2);</span><br><span class="line">        users.add(u1);</span><br><span class="line">        </span><br><span class="line">        System.out.println(u1.hashCode());</span><br><span class="line">        System.out.println(u2.hashCode());</span><br><span class="line">        System.out.println(u1.equals(u2));</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        LinkedHashSet&lt;User&gt; users1 = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">&quot;fg&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">&quot;fan&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        users1.add(u4);</span><br><span class="line">        users1.add(u3);</span><br><span class="line">        System.out.println(users1);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Tom, Tomos, Jerry]</span><br><span class="line">134277</span><br><span class="line">71512688</span><br><span class="line">false</span><br><span class="line">[User [id&#x3D;2, name&#x3D;Jerry, age&#x3D;21, hashCode&#x3D;71512688], User [id&#x3D;1, name&#x3D;Tom, age&#x3D;21, hashCode&#x3D;134277]]</span><br><span class="line">---------------</span><br><span class="line">[User [id&#x3D;4, name&#x3D;fan, age&#x3D;22, hashCode&#x3D;152196], User [id&#x3D;3, name&#x3D;fg, age&#x3D;22, hashCode&#x3D;54291]]</span><br></pre></td></tr></table></figure><h4 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode() 方法"></a>hashCode() 方法</h4><ul><li>如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。</li><li><strong>对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。</strong></li><li>重写 hashCode() 方法的基本原则<ul><li>在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值</li><li>当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode() 方法的返回值也应相等</li><li>对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值</li></ul></li></ul><h3 id="Set实现类之二：LinkedHashSet"><a href="#Set实现类之二：LinkedHashSet" class="headerlink" title="Set实现类之二：LinkedHashSet"></a>Set实现类之二：LinkedHashSet</h3><ul><li>LinkedHashSet 是 HashSet 的子类</li><li>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</li><li>LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</li><li>LinkedHashSet 不允许集合元素重复。</li></ul><h3 id="Set实现类之三：TreeSet"><a href="#Set实现类之三：TreeSet" class="headerlink" title="Set实现类之三：TreeSet"></a>Set实现类之三：TreeSet</h3><ul><li>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- <span class="function">Comparator <span class="title">comparator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">- Object <span class="title">first</span><span class="params">()</span></span></span><br><span class="line"><span class="function">- Object <span class="title">last</span><span class="params">()</span></span></span><br><span class="line"><span class="function">- Object <span class="title">lower</span><span class="params">(Object e)</span></span></span><br><span class="line"><span class="function">- Object <span class="title">higher</span><span class="params">(Object e)</span></span></span><br><span class="line"><span class="function">- SortedSet <span class="title">subSet</span><span class="params">(fromElement, toElement)</span></span></span><br><span class="line"><span class="function">- SortedSet <span class="title">headSet</span><span class="params">(toElement)</span></span></span><br><span class="line"><span class="function">- SortedSet <span class="title">tailSet</span><span class="params">(fromElement)</span></span></span><br></pre></td></tr></table></figure>示例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; ints = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//Integer自己定义了排序规则,所以能够实现TreeSet中的排序(自然排序)</span></span><br><span class="line">        ints.add(<span class="number">30</span>);</span><br><span class="line">        ints.add(<span class="number">50</span>);</span><br><span class="line">        ints.add(<span class="number">12</span>);</span><br><span class="line">        ints.add(<span class="number">23</span>);</span><br><span class="line">        System.out.println(ints);</span><br><span class="line">        </span><br><span class="line">        TreeSet&lt;String&gt; strs = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">//String自己定义了排序规则</span></span><br><span class="line">        strs.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        strs.add(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        strs.add(<span class="string">&quot;ffg&quot;</span>);</span><br><span class="line">        System.out.println(strs);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//加入元素的自然排序规则不能满足要求,可以自己定义排序器进行定制排序</span></span><br><span class="line">        TreeSet&lt;String&gt; strs1 = <span class="keyword">new</span> TreeSet&lt;String&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.length()-o2.length();    <span class="comment">//按长度排序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        strs1.add(<span class="string">&quot;qq&quot;</span>);</span><br><span class="line">        strs1.add(<span class="string">&quot;qqq&quot;</span>);</span><br><span class="line">        strs1.add(<span class="string">&quot;qqqq&quot;</span>);</span><br><span class="line">        System.out.println(strs1);</span><br><span class="line">        </span><br><span class="line">        TreeSet&lt;User&gt; users = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;Tom&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">&quot;fg&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">&quot;fan&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        users.add(u1);</span><br><span class="line">        users.add(u2);</span><br><span class="line">        users.add(u3);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>结果：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[12, 23, 30, 50]</span><br><span class="line">[Jerry, Tom, ffg]</span><br><span class="line">[qq, qqq, qqqq]</span><br><span class="line">[User [id&#x3D;1, name&#x3D;Tom, age&#x3D;22, hashCode&#x3D;135238], User [id&#x3D;2, name&#x3D;fan, age&#x3D;22, hashCode&#x3D;152134], User [id&#x3D;4, name&#x3D;fg, age&#x3D;22, hashCode&#x3D;54322]]</span><br></pre></td></tr></table></figure></li></ul><ul><li>TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。</li></ul><h4 id="排序——自然排序"><a href="#排序——自然排序" class="headerlink" title="排序——自然排序"></a>排序——自然排序</h4><ul><li>自然排序：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序排列</li><li><strong>如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。</strong></li><li>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。</li><li>Comparable 的典型实现：<ul><li>BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较</li><li>Character：按字符的 unicode值来进行比较</li><li>Boolean：true 对应的包装类实例大于 false 对应的包装类实例</li><li>String：按字符串中字符的 unicode 值进行比较</li><li>Date、Time：后边的时间、日期比前面的时间、日期大</li></ul></li><li>向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。</li><li>因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同一个类的对象</li><li>对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值</li><li>当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与 compareTo(Object obj) 方法有一致的结果：如果两个对象通过 equals() 方法比较返回 true，则通过 compareTo(Object obj) 方法比较应返回 0</li><li>TreeSet的自然排序是根据集合元素的大小，进行元素升序排列。如果需要定制排序，比如降序排列，可通过Comparator接口的帮助。需要重写compare(T o1,T o2)方法。</li><li>利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li><li>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</li><li>此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。</li><li>使用定制排序<strong>判断两个元素相等的标准</strong>是：通过Comparator比较两个元素返回了0。</li></ul><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><ul><li>Map与Collection并列存在。用于保存具有映射关系的数据:Key-Value</li><li>Map 中的 key 和  value 都可以是任何引用类型的数据</li><li>Map 中的 key 用Set来存放，不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法。</li><li>常用String类作为Map的“键”。</li><li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value。</li></ul><img src="/2020/%E9%9B%86%E5%90%88/image-20200820171549434.png" class="" title="image-20200820171549434"><h3 id="Map-常用方法"><a href="#Map-常用方法" class="headerlink" title="Map 常用方法"></a>Map 常用方法</h3><h4 id="添加、删除操作："><a href="#添加、删除操作：" class="headerlink" title="添加、删除操作："></a>添加、删除操作：</h4><pre><code>- Object put(Object key,Object value)- Object remove(Object key)- void putAll(Map t)- void clear()</code></pre><h4 id="元视图操作的方法"><a href="#元视图操作的方法" class="headerlink" title="元视图操作的方法"></a>元视图操作的方法</h4><pre><code>- Set keySet()- Collection values()- Set entrySet()</code></pre><h4 id="元素查询的操作"><a href="#元素查询的操作" class="headerlink" title="元素查询的操作"></a>元素查询的操作</h4><pre><code>- Object get(Object key)- boolean containsKey(Object key)- boolean containsValue(Object value)- int size()- boolean isEmpty()- boolean equals(Object obj)</code></pre><h3 id="Map-实现类之一：HashMap"><a href="#Map-实现类之一：HashMap" class="headerlink" title="Map 实现类之一：HashMap"></a>Map 实现类之一：HashMap</h3><ul><li>Map接口的常用实现类：HashMap、TreeMap和Properties。</li><li>HashMap是 Map 接口使用频率最高的实现类。</li><li>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</li><li>HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，hashCode 值也相等。</li><li>HashMap 判断两个 value相等的标准是：两个 value 通过 equals() 方法返回 true。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        </span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Fg&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(map.get(<span class="number">2</span>));    <span class="comment">//get根据key获取value</span></span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Tim&quot;</span>);    <span class="comment">//如果有相同的key,则替换旧值</span></span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//获得所有的key</span></span><br><span class="line">        Set&lt;Integer&gt; keys = map.keySet();    <span class="comment">//得到所有的key(集合)</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = keys.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Integer key = it.next();</span><br><span class="line">            System.out.println(key+<span class="string">&quot;=&quot;</span>+map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取所有的entry</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrys = map.entrySet();</span><br><span class="line">        Iterator&lt; Map.Entry&lt;Integer, String&gt; &gt; its = entrys.iterator();</span><br><span class="line">        <span class="keyword">while</span>(its.hasNext()) </span><br><span class="line">        &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = its.next();</span><br><span class="line">            System.out.println(entry.getKey()+<span class="string">&quot;=&quot;</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jerry</span><br><span class="line">&#123;1&#x3D;Tom, 2&#x3D;Jerry, 3&#x3D;Tim&#125;</span><br><span class="line">------------------------</span><br><span class="line">1&#x3D;Tom</span><br><span class="line">2&#x3D;Jerry</span><br><span class="line">3&#x3D;Tim</span><br><span class="line">------------------------</span><br><span class="line">1&#x3D;Tom</span><br><span class="line">2&#x3D;Jerry</span><br><span class="line">3&#x3D;Tim</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure><h3 id="Map-实现类之二：LinkedHashMap"><a href="#Map-实现类之二：LinkedHashMap" class="headerlink" title="Map 实现类之二：LinkedHashMap"></a>Map 实现类之二：LinkedHashMap</h3><ul><li>LinkedHashMap 是 HashMap 的子类</li><li>与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致</li></ul><h3 id="Map实现类之三：TreeMap"><a href="#Map实现类之三：TreeMap" class="headerlink" title="Map实现类之三：TreeMap"></a>Map实现类之三：TreeMap</h3><ul><li>TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态。</li><li>TreeMap 的 Key 的排序：<ul><li><strong>自然排序</strong>：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException</li><li><strong>定制排序</strong>：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口</li></ul></li><li>TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。</li><li>若使用自定义类作为TreeMap的key，所属类需要重写equals()和hashCode()方法，且equals()方法返回true时，compareTo()方法应返回0。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;String,User&gt; user = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;Tom&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">&quot;Jerry&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        user.put(<span class="string">&quot;001&quot;</span>, u2);</span><br><span class="line">        user.put(<span class="string">&quot;002&quot;</span>, u1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        TreeMap&lt;User,String&gt; user1 = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        user1.put(u2, <span class="string">&quot;002&quot;</span>);</span><br><span class="line">        user1.put(u1, <span class="string">&quot;001&quot;</span>);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        TreeMap&lt;User,String&gt; user2 = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;User&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User o1, User o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                <span class="keyword">return</span> o2.getId()-o1.getId();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        user2.put(u2, <span class="string">&quot;001&quot;</span>);</span><br><span class="line">        user2.put(u1, <span class="string">&quot;001&quot;</span>);</span><br><span class="line">        System.out.println(user2);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;001&#x3D;User [id&#x3D;2, name&#x3D;Jerry, age&#x3D;22, hashCode&#x3D;71513649], 002&#x3D;User [id&#x3D;1, name&#x3D;Tom, age&#x3D;22, hashCode&#x3D;135238]&#125;</span><br><span class="line">------------------------</span><br><span class="line">&#123;User [id&#x3D;1, name&#x3D;Tom, age&#x3D;22, hashCode&#x3D;135238]&#x3D;001, User [id&#x3D;2, name&#x3D;Jerry, age&#x3D;22, hashCode&#x3D;71513649]&#x3D;002&#125;</span><br><span class="line">------------------------</span><br><span class="line">&#123;User [id&#x3D;2, name&#x3D;Jerry, age&#x3D;22, hashCode&#x3D;71513649]&#x3D;001, User [id&#x3D;1, name&#x3D;Tom, age&#x3D;22, hashCode&#x3D;135238]&#x3D;001&#125;</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure><h3 id="Map实现类之四：Hashtable"><a href="#Map实现类之四：Hashtable" class="headerlink" title="Map实现类之四：Hashtable"></a>Map实现类之四：Hashtable</h3><ul><li>Hashtable是个古老的 Map 实现类，线程安全。</li><li>与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value</li><li>与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序</li><li>Hashtable判断两个key相等、两个value相等的标准，与hashMap一致。</li></ul><h3 id="Map实现类之五：Properties"><a href="#Map实现类之五：Properties" class="headerlink" title="Map实现类之五：Properties"></a>Map实现类之五：Properties</h3><ul><li>Properties 类是 Hashtable 的子类，该对象用于处理属性文件</li><li>由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型</li><li>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法<h4 id="读取属性文件："><a href="#读取属性文件：" class="headerlink" title="读取属性文件："></a>读取属性文件：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">pros.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;jdbc.properties&quot;</span>));</span><br><span class="line">String user = pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure></li></ul><h1 id="集合操作的工具类-Collections"><a href="#集合操作的工具类-Collections" class="headerlink" title="集合操作的工具类 Collections"></a>集合操作的工具类 Collections</h1><ul><li>Collections 是一个操作 Set、List 和 Map 等集合的工具类</li><li>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</li><li>排序操作：（均为static方法）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- reverse(List)：反转 List 中元素的顺序</span><br><span class="line">- shuffle(List)：对 List 集合元素进行随机排序</span><br><span class="line">- sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span><br><span class="line">- sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span><br><span class="line">- swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span><br><span class="line">-查找、替换</span><br><span class="line">- Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</span><br><span class="line">- Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</span><br><span class="line">- Object min(Collection)</span><br><span class="line">- Object min(Collection，Comparator)</span><br><span class="line">- int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</span><br><span class="line">- void copy(List dest,List src)：将src中的内容复制到dest中</span><br><span class="line">- boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</span><br></pre></td></tr></table></figure></li></ul><h1 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h1><ul><li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</li></ul><p>本章完</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;集合概述&quot;&gt;&lt;a href=&quot;#集合概述&quot; class=&quot;headerlink&quot; title=&quot;集合概述&quot;&gt;&lt;/a&gt;集合概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;为了方便对多个对象的操作，就要对对象进行存储。使用Array（数组）存储对象方面具有一些弊端，如：长度问题，而J</summary>
      
    
    
    
    
    <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
</feed>
